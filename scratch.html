<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.547">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>scratch</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="scratch_files/libs/clipboard/clipboard.min.js"></script>
<script src="scratch_files/libs/quarto-html/quarto.js"></script>
<script src="scratch_files/libs/quarto-html/popper.min.js"></script>
<script src="scratch_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="scratch_files/libs/quarto-html/anchor.min.js"></script>
<link href="scratch_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="scratch_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="scratch_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="scratch_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="scratch_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="butchery-i" class="level4">
<h4 class="anchored" data-anchor-id="butchery-i">Butchery I</h4>
<p><strong>Requirements:</strong> 1 STR<br>
<strong>Cost:</strong> 5 SP<br>
When you roll matching dice with a [Severing] weapon, do 1 crit damage and apply apply an [injury] that disables one of the enemy’s limbs.</p>
</section>
<section id="butchery-ii" class="level4">
<h4 class="anchored" data-anchor-id="butchery-ii">Butchery II</h4>
<p><strong>Requirements:</strong> 3 STR, Butchery I<br>
<strong>Cost:</strong> 5 SP<br>
Replaces Butchery I. When you roll a half crit with a [Severing] weapon, do 1 crit damage and apply an [injury] that disables one of the enemy’s limbs. On full crit, remove the limb.</p>
</section>
<section id="charge" class="level4">
<h4 class="anchored" data-anchor-id="charge">Charge</h4>
<p><strong>Cost:</strong> 5 SP<br>
Pay 1 AP. Move double your movement speed in a straight line. You must move at least two spaces. Once you reach an enemy, you may perform an attack, paying AP as usual. Before you roll your attack you can choose to add your STR to the damage or to your attack roll. If you are entering a STR contest of some kind, add your STR to your roll.</p>
</section>
<section id="chokehold" class="level4">
<h4 class="anchored" data-anchor-id="chokehold">Chokehold</h4>
<p><strong>Requirements:</strong> {Grappling Adept}<br>
<strong>Cost:</strong> 4 SP<br>
You must be grappling your target and your target must be [prone] for you to perform a Chokehold. Spend 2 AP to initiate a Chokehold. The target can try to break out of the grapple while you are performing the Chokehold. You cannot do anything else while performing the Chokehold. The Chokehold costs 2 AP to maintain every turn. On the start of the third round in the Chokehold, the target becomes [unconscious] for 1d12 minutes. The Chokehold ends if you take damage from any non-unarmed attack. Chokehold cannot be performed on a target wearing a full helmet, or has a gaseous form, doesn’t have a neck, etc.</p>
</section>
<section id="clobber" class="level4">
<h4 class="anchored" data-anchor-id="clobber">Clobber</h4>
<p><strong>Requirements:</strong> 1 STR<br>
<strong>Cost:</strong> 5 SP<br>
Take disadvantage on an attack that costs at least 2 AP. Add your STR to the damage if it hits.</p>
</section>
<section id="control" class="level4">
<h4 class="anchored" data-anchor-id="control">Control</h4>
<p><strong>Requirements:</strong> {Grappling Adept}<br>
<strong>Cost:</strong> 2 SP<br>
You must be grappling your target and your target must be [prone] for you to use Control. Spend 2 AP to initiate Control. The target has disadvantage when attempting to end or reverse the grapple. You cannot do anything else while maintaining Control. Control costs 2 AP to maintain every turn.</p>
</section>
<section id="crush" class="level4">
<h4 class="anchored" data-anchor-id="crush">Crush</h4>
<p><strong>Requirements:</strong> 2 STR, a [swinging] (B) attack that uses +STR to-hit<br>
<strong>Cost:</strong> 1 SP<br>
Spend an extra 1 AP. If crush hits, use the attack roll as a check against the enemies STR. If the attacking roll is higher, the defender is knocked prone and [vulnerable].</p>
</section>
<section id="grappling-adept" class="level4">
<h4 class="anchored" data-anchor-id="grappling-adept">Grappling Adept</h4>
<p><strong>Requirements:</strong> 0 STR<br>
<strong>Cost:</strong> 10 SP<br>
+2 to grapple checks. If you are being grappled, you can spend 1 AP to perform a grapple check. If you succeed, you are the one grappling and your opponent is being grappled.</p>
</section>
<section id="grappling-expert" class="level4">
<h4 class="anchored" data-anchor-id="grappling-expert">Grappling Expert</h4>
<p><strong>Requirements:</strong> 0 STR, {Grappling Adept}<br>
<strong>Cost:</strong> 20 SP<br>
+4 to grapple checks. All Grappling skills cost 1 AP to perform. You can grapple opponents one size category larger than you. Treat your STR as +2 while you are grappling your opponent (does not apply to grapple checks).</p>
</section>
<section id="hard-to-kill" class="level4">
<h4 class="anchored" data-anchor-id="hard-to-kill">Hard to Kill</h4>
<p><strong>Requirements:</strong> 1 STR, 1 WIL<br>
<strong>Cost:</strong> 10 SP<br>
When you would be killed or downed by less damage than your total standard health (not your current standard health), flip a coin. If it comes up heads, you stay standing with 1 crit health.</p>
</section>
<section id="hearty" class="level4">
<h4 class="anchored" data-anchor-id="hearty">Hearty</h4>
<p><strong>Cost:</strong> 9 SP<br>
Get +1:+3 max health. You can take this skill once for every point of STR you have.</p>
</section>
<section id="jackassery" class="level4">
<h4 class="anchored" data-anchor-id="jackassery">Jackassery</h4>
<p><strong>Requirements:</strong> 0 STR<br>
<strong>Cost:</strong> 7 SP<br>
Take half damage from falling. Take half damage when you choose to jump through glass windows, run through burning buildings, or do other things that are wildly unsafe.</p>
</section>
<section id="large-weapon-1-two-handed-proficiency" class="level4">
<h4 class="anchored" data-anchor-id="large-weapon-1-two-handed-proficiency">Large Weapon 1: [two-handed] Proficiency</h4>
<p><strong>Requirements:</strong> 2 STR<br>
<strong>Cost:</strong> 5 SP<br>
Treat your Strength as 1 higher (for weapon related rolls) when wielding two handed weapons.</p>
</section>
<section id="large-weapon-2-giant-weapon-efficiency" class="level4">
<h4 class="anchored" data-anchor-id="large-weapon-2-giant-weapon-efficiency">Large Weapon 2: Giant Weapon Efficiency</h4>
<p><strong>Requirements:</strong> {Large Weapon 2}, AGI 1<br>
<strong>Cost:</strong> 10 SP<br>
When you land a hit with a [giant] weapon, gain 1 Temp AP.</p>
</section>
<section id="large-weapon-2-giant-weapon-proficiency" class="level4">
<h4 class="anchored" data-anchor-id="large-weapon-2-giant-weapon-proficiency">Large Weapon 2: Giant Weapon Proficiency</h4>
<p><strong>Requirements:</strong> {Large Weapon 1}<br>
<strong>Cost:</strong> 5 SP<br>
Treat your Strength as 1 higher (for weapon related rolls) when wielding a weapon with the [giant] tag.</p>
</section>
<section id="large-weapon-2-sweep" class="level4">
<h4 class="anchored" data-anchor-id="large-weapon-2-sweep">Large Weapon 2: Sweep</h4>
<p><strong>Requirements:</strong> {Large Weapon 1}, STR 2<br>
<strong>Cost:</strong> 5 SP<br>
When you perform a non-(P) melee attack with a [two-handed] weapon or a weapon with [reach], you can treat it as an attack against two adjacent enemies that you can hit. Roll only once, resolve the attack separately for each enemy. You can spend an extra 1 AP and attack up to four adjacent enemies in the same way.</p>
</section>
<section id="shield-bash" class="level4">
<h4 class="anchored" data-anchor-id="shield-bash">Shield Bash</h4>
<p><strong>Cost:</strong> 4 SP<br>
You can attack with a shield as +STR to hit, 1 Damage [B]. Knock the enemy prone on a half crit.</p>
</section>
<section id="slam" class="level4">
<h4 class="anchored" data-anchor-id="slam">Slam</h4>
<p><strong>Requirements:</strong> {Grappling Adept}<br>
<strong>Cost:</strong> 4 SP<br>
You can perform a Slam while grappling unless you or your target is [prone]. Spend 2 AP. Deal 1d4 (B). You are still grappling your target. Your target is [prone].</p>
</section>
<section id="submission" class="level4">
<h4 class="anchored" data-anchor-id="submission">Submission</h4>
<p><strong>Requirements:</strong> {Grappling Adept}<br>
<strong>Cost:</strong> 4 SP<br>
You must be grappling your target and your target must be [prone] for you to perform a Submission. Spend 2 AP to initiate a Submission. Perform a STR check. If you succeed, choose which limb to injure. For humanoids you can injure an arm or leg. Injuring an arm means the target has disadvantage when trying to do anything with that arm for an hour, injuring a leg lowers the targets movement speed by 2.</p>
</section>
<section id="takedown" class="level4">
<h4 class="anchored" data-anchor-id="takedown">Takedown</h4>
<p><strong>Requirements:</strong> {Grappling Adept}<br>
<strong>Cost:</strong> 4 SP<br>
Using Takedown costs 2 AP. You can take a move action when you use it. Make a [range: close] attack, if you succeed, the target is knocked prone and you are grappling them. You are treated as by everyone except your target.</p>
</section>
<section id="throw" class="level4">
<h4 class="anchored" data-anchor-id="throw">Throw</h4>
<p><strong>Requirements:</strong> {Grappling Adept}<br>
<strong>Cost:</strong> 4 SP<br>
You can perform a Throw while grappling or being grappled unless you or your target is [prone]. Spend 2 AP. Perform a STR check. If you succeed, Throw your target STR spaces, up to 3 spaces. Your target lands [prone].</p>
</section>
<section id="unstoppable" class="level4">
<h4 class="anchored" data-anchor-id="unstoppable">Unstoppable</h4>
<p><strong>Requirements:</strong> 1 STR<br>
<strong>Cost:</strong> 9 SP<br>
Ignore the effects of a number of [stun], [injury], [poison], and [bleed] status effects up to your STR in the order that you recieve the statuses. The statuses must still be treated or resolve themselves, you just ignore their effects.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>